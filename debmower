#!/bin/bash
# debmower - a tool to build your linux images
# https://github.com/highvoltage/debmower
#
# Copyright (c) 2008-2015 Jonathan Carter
# This file is released under the MIT/expat license.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# Set languages to system language, prevents some spewage on console
export CONFIG="$1"
export LANG=C
export LANGUAGE=C
export LC_ALL=C

if [ ! "$UID" = "0" ]; then
    echo "This script is intended to run with root privileges. \
          Your UID is $UID."
    exit 403
fi

# Defaults
# This is the Debmower Version used in logs
DEBMOWER="0.3.1"
# debian, ubuntu
SYSTEM="ubuntu"
# eg, 16384, 32768
BLOCKSIZE="65536"
# eg, ubuntu-trusty, custom-disk
NAME="$SYSTEM-custom-spin"
# Version of /your/ disc/release
VERSION="0.01"
# iso filename
ISONAME="$NAME-$VERSION.iso"
ISOPATH="../"
# Where base images are stored
CACHEDIR="/var/cache/debmower/dists"
# Where the squashfs contents are put together
CHROOT="/var/cache/debmower/chroot"
# Directory where work happens
IMAGEDIR="/var/cache/debmower/image"
RAMDISK="no"
# Where to log stuff
LOGPATH=/var/log/debmower/build.$$
# Architecture (i386, amd64, ppc, armhf)
ARCH="amd64"
# What kind of image are we building? iso, usb
IMAGETYPE="iso"
# Compression used for squashfs
COMP="gzip" #gzip lzo xz
# If update_initramfs is required for kernels
UPDATE_INITRAMFS="no"
# Auto remove packages that are marked as no longer needed
AUTOREMOVE="yes"
# Generate an ID for this build
BUILD_ID=$(uuidgen -t)
# Populate /isolinux
GENISOLINUX_STRUCTURE="yes"

# Source configuration, if specified
if [ "$CONFIG" != "" ]; then
    if [ -f $CONFIG ]; then
        . $CONFIG
    else
        echo "Specified configuration file not found, aborting..."
    exit
    fi
else
    echo "No configuration specified, continuing with defaults..."
fi

# We make some assumptions on what the user will want based on the
# type of system they are building. The user can specify alternatives
# in their configuration file.
if [ "$SYSTEM" = "debian" ]; then
    LIVESYSTEM="live=LIVE"
    LIVEDIR="live"
    # eg, wheezy, jessie
    RELEASE="wheezy"
    # eg, linux-image-686
    KERNEL="linux-image-686"
    # LIVECD should ideally specify one meta-package:
    LIVECD="live-boot live-boot-initramfs-tools live-config \
            live-config-sysvinit debian-installer-launcher \
            debian-installer libdebian-installer-extra4 \
            libdebian-installer4"
    # MAINMETA should ideally specify one meta-package:
    MAINMETA="gnome-session-fallback gnome-terminal strace locales \
              less"
    # how this system installs packages
    INSTALL="apt-get -qq -y install --force-yes "
    # eg, noninteractive, text
    DEBIAN_FRONTEND="noninteractive"
    # Disk Image template
    TEMPLATE="/usr/share/doc/debmower/examples/template/debian"
    DEBOOTSTRAP_MIRROR="http://http.debian.net/debian"
    ISOHYBRID="yes"
    SOURCESLIST="deb $DEBOOTSTRAP_MIRROR $RELEASE main"
    CACHEIMG=$RELEASE-$ARCH
fi

if [ "$SYSTEM" = "ubuntu" ]; then
    LIVESYSTEM="live=casper"
    LIVEDIR="casper"
    # eg, precise, trusty
    RELEASE="trusty"
    # eg, linux-image-generic
    KERNEL="linux-image-generic"
    # LIVECD should ideally specify one meta-package:
    LIVECD="ubiquity casper user-setup xresprobe libdebian-installer4 \
            os-prober ubiquity-frontend-gtk ubiquity-slideshow-ubuntu \
            libdevmapper-event1.02.1 ubiquity-slideshow-ubuntu"
    # MAINMETA should ideally specify one meta-package:
    MAINMETA="ubuntu-desktop"
    # how this system installs packages, the space at the end is important
    INSTALL="apt-get -qq -y install --force-yes "
    # Which releases to cache
    CACHEDISTS="trusty"
    # eg, noninteractive, text
    DEBIAN_FRONTEND="noninteractive"
    TEMPLATE="/usr/share/doc/debmower/examples/template/ubuntu"
    DEBOOTSTRAP_MIRROR="http://archive.$SYSTEM.com/$SYSTEM"
    ISOHYBRID="yes"
    SOURCESLIST="deb $BOOTSTRAP_MIRROR $RELEASE main"
    CACHEIMG=$RELEASE-$ARCH
fi

# Source configuration, if specified
if [ "$CONFIG" != "" ]; then
    if [ -f $CONFIG ]; then
        . $CONFIG
    else
        echo "Specified configuration file not found, aborting..."
    exit
     fi
else
    echo "No configuration specified, continuing with defaults..."
fi

function initenv {
    # Initialise environment
    echo "Debmower version $DEBMOWER, building $NAME, from $SYSTEM $RELEASE $ARCH packages" \
         > $LOGPATH
    echo "debmower: this build ID is $BUILD_ID" >> $LOGPATH
    echo "" > $LOGPATH.aptlog
    echo "debmower: $(date +%H:%M:%S) Preparing directories..." >> $LOGPATH
    rm -rf $IMAGEDIR $CHROOT
    echo "debmower: $(date +%H:%M:%S) (enabling a ramdisk build)" >> $LOGPATH

    mkdir -p /tmp/debmower
    mount -t tmpfs tmpfs /tmp/debmower

    mkdir -p $CHROOT
    mkdir -p /mnt/debmower/squashfs
    mount $CACHEDIR/$CACHEIMG.squashfs /mnt/debmower/squashfs

    echo "debmower: $(date +%H:%M:%S) Mounting unionfs filesystem..." \
          >> $LOGPATH
    unionfs-fuse -o cow,max_files=32768,use_ino,suid,dev \
                 /tmp/debmower=RW:/mnt/debmower/squashfs=RO \
                 $CHROOT
    abort_on_fail
    chroot_bind_mounts
    echo "none none none none 0 0" > $CHROOT/etc/mtab
    if [ ! -f $CACHEDIR/$CACHEIMG.squashfs ]; then
        updatecache
    fi
    cp /etc/resolv.conf $CHROOT/etc
    echo "debmower: $(date +%H:%M:%S) Setting up APT sources and updating..." \
         >> $LOGPATH
    echo -e $SOURCESLIST | sed -e "s/RELEASE/$RELEASE/g" \
         > $CHROOT/etc/apt/sources.list
    LANG=C LANGUAGE=C LC_ALL=C chroot $CHROOT apt-get -q update &>> $LOGPATH.aptlog
    abort_on_fail
    if [ "$UPDATE_TEMPLATE" = "yes" ]; then
        echo "debmower: $(date +%H:%M:%S) Updating template at your request..." \
             >> $LOGPATH
        # Doesn't work in trusty due to policykit-1 bug in 0.105-4ubuntu2.14.04.1
        chroot $CHROOT apt-get -q -y dist-upgrade &>> $LOGPATH.aptlog
        abort_on_fail
    fi

}


function system_install {
    # Ubuntu 14.04 workarounds...
    touch $CHROOT/etc/init.d/{systemd-logind,whoopsie,modemmanager}
    echo "debmower: $(date +%H:%M:%S) Setting dbus machine ID..." >> $LOGPATH
    mkdir -p $CHROOT/var/lib/dbus/
    dbus-uuidgen > $CHROOT/var/lib/dbus/machine-id ; abort_on_fail
    echo "debmower: $(date +%H:%M:%S) Installing main meta-package..." \
         &>> $LOGPATH
    chroot $CHROOT ldconfig
    DEBIAN_FRONTEND=$DEBIAN_FRONTEND chroot $CHROOT $INSTALL \
                    $MAINMETA &>> $LOGPATH.aptlog ; abort_on_fail
    echo "debmower: $(date +%H:%M:%S) Installing kernel..." >> $LOGPATH
    DEBIAN_FRONTEND=$DEBIAN_FRONTEND chroot $CHROOT $INSTALL \
                    $KERNEL &>> $LOGPATH.aptlog ; abort_on_fail
    echo "debmower: tmpfs size is $(df -h /tmp/debmower | grep debmower | awk '{print $2}')" \
         &>> $LOGPATH
    echo "debmower: tmpfs usage at end was $(df -h /tmp/debmower | grep debmower | awk '{print $4}')" \
         &>> $LOGPATH
}


function setup_livecd {
    # Create a manifest file if we use Ubiquity (or for now, Ubuntu, at least)
    # We need to do this before the livecd packages are installed
    if [ "$SYSTEM" = "ubuntu" ]; then
        chroot $CHROOT dpkg-query -W --showformat='${Package} ${Version}\n' \
                       | tee $IMAGEDIR/$LIVEDIR/filesystem.manifest \
                         &>> $LOGPATH.manifest
    fi
    # Set up Live CD
    echo "debmower: $(date +%H:%M:%S) Installing live packages..." >> $LOGPATH
    chroot $CHROOT $INSTALL $LIVECD &>> $LOGPATH.aptlog
    abort_on_fail
    echo "debmower: $(date +%H:%M:%S) Setting up live kernels..." >> $LOGPATH
    if [ "$UPDATE_INITRAMFS" = "yes" ]; then
        chroot $CHROOT update-initramfs -u &>> $LOGPATH
    fi
    # The initrd needs to be compressed with lzma, so we need to decompress it from
    # the default gzip first.
    cp $CHROOT/boot/vmlinuz-* $IMAGEDIR/$LIVEDIR/vmlinuz.efi &>> $LOGPATH
    cp $CHROOT/boot/initrd.img-* $IMAGEDIR/$LIVEDIR/initrd.img.gz &>> $LOGPATH
    gzip -d $IMAGEDIR/$LIVEDIR/initrd.img.gz &>> $LOGPATH
    lzma $IMAGEDIR/$LIVEDIR/initrd.img &>> $LOGPATH
    mv $IMAGEDIR/$LIVEDIR/initrd.img.lzma $IMAGEDIR/$LIVEDIR/initrd.lz
    echo "debmower: $(date +%H:%M:%S) Copying cdimage boot files and artwork..." \
          >> $LOGPATH
    cp  -r $TEMPLATE/* $IMAGEDIR &>> $LOGPATH
    if [ "$GENISOLINUX_STRUCTURE" = "yes" ]; then
        echo "debmower: $(date +%H:%M:%S) Configuring isolinux structure..." >> $LOGPATH
        cp /usr/lib/ISOLINUX/isolinux.bin /usr/lib/syslinux/modules/bios/ldlinux.c32 \
           /usr/lib/syslinux/modules/bios/vesamenu.c32 /usr/lib/syslinux/modules/bios/libcom32.c32 \
           /usr/lib/syslinux/modules/bios/libutil.c32 /usr/lib/syslinux/modules/bios/gfxboot.c32 \
           /usr/lib/syslinux/modules/bios/chain.c32 \
           $IMAGEDIR/isolinux/ &>> $LOGPATH ; abort_on_fail
    fi

    if [ -f "$TEMPLATE/README.diskdefines" ]; then
        cp $TEMPLATE/README.diskdefines $IMAGEDIR/
    else
        cat << EOF > $IMAGEDIR/README.diskdefines
#define DISKNAME  $NAME - $ARCH
#define TYPE binary
#define TYPEbinary 1
#define ARCH $ARCH
#define ARCH$ARCH 1
#define DISKNUM 1
#define DISKNUM1 1
#define TOTALNUM 0
#define TOTALNUM0 1
EOF
    fi

    # Copy Custom CD root data
    if [ -d $TEMPLATE/cdroot ]; then
        cp -r $TEMPLATE/cdroot/. $IMAGEDIR/
    fi

    # Write unique ID for this disk
    mkdir -p $IMAGEDIR/.disk
    echo $BUILD_ID > $IMAGEDIR/.disk/casper-uuid-generic

    # Write, release-url, if set
    if [ ! -z $RELEASE_NOTES_URL ]; then
        echo $RELEASE_NOTES_URL > $IMAGEDIR/.disk/release_notes_url
    fi

    # Copy memtest86:
    if [ -f /boot/memtest86+.bin ]; then
        cp /boot/memtest86+.bin $IMAGEDIR/isolinux/mt86plus
    fi

    echo "debmower: $(date +%H:%M:%S) Cleaning up..." >> $LOGPATH
    chroot $CHROOT apt-get clean
    rm -rf $CHROOT/tmp/*
    echo "nameserver 127.0.1.1" > $CHROOT/etc/resolv.conf
    chroot $CHROOT rm -rf /var/lib/dbus/machine-id /tmp/*
    chroot_bind_unmounts
    echo "localhost" > $CHROOT/etc/hostname
    if [ "$AUTOREMOVE" = "yes" ]; then
        chroot $CHROOT apt-get -qq -y autoremove &>> $LOGPATH.aptlog
    fi
    # Create a manifest file if we use Ubiquity (or for now, Ubuntu, at least)
    if [ "$SYSTEM" = "ubuntu" ]; then
        chroot $CHROOT dpkg-query -W --showformat='${Package} ${Version}\n' \
                       > $IMAGEDIR/$LIVEDIR/filesystem.manifest-afterlive
        MANIFEST_PKG=$(wc -l $IMAGEDIR/$LIVEDIR/filesystem.manifest | awk '{print $1}')
        cp $IMAGEDIR/$LIVEDIR/filesystem.manifest{,-desktop}
        diff $IMAGEDIR/$LIVEDIR/filesystem.manifest $IMAGEDIR/$LIVEDIR/filesystem.manifest-afterlive \
                     | grep ">" | sed "s/> //g" > $IMAGEDIR/$LIVEDIR/filesystem.manifest-remove
        rm $IMAGEDIR/$LIVEDIR/filesystem.manifest-afterlive
        REMOVE=$(awk '{print $1}' $IMAGEDIR/$LIVEDIR/filesystem.manifest-remove)
        for package in $REMOVE; do
            sed -i "/${package}/d" $IMAGEDIR/$LIVEDIR/filesystem.manifest-desktop
        done
        MANIFEST_PKG_RM=$(wc -l $IMAGEDIR/$LIVEDIR/filesystem.manifest-remove | \
                          awk '{print $1}')
    fi
    if [ "$STORE_DPKGDB" = "yes" ]; then
        mkdir -p /var/cache/debmower/builddata/$BUILD_ID/
        mksquashfs $CHROOT/var/lib/dpkg /var/cache/debmower/builddata/$BUILD_ID/dpkgdb.squashfs \
                   -noappend &>> $LOGPATH
    fi
    echo "Top 10 biggest packages:" &>> $LOGPATH
    chroot $CHROOT dpkg-query -W --showformat='${Installed-Size}\t${Package}\n' | sort -nr | head -n 10 \
           &>> $LOGPATH
    echo "debmower: debsums report:" >> $LOGPATH
    debsums -c -r $CHROOT &>> $LOGPATH
    echo "End of debsums report." >> $LOGPATH
}


function build_cd_image {
    echo "debmower: $(date +%H:%M:%S) Creating squashfs image..." >> $LOGPATH
    mksquashfs $CHROOT $IMAGEDIR/$LIVEDIR/filesystem.squashfs \
               -b $BLOCKSIZE -comp $COMP -noappend -no-progress \
               &> $LOGPATH.squashfs ; abort_on_fail
    echo "debmower: $(date +%H:%M:%S) Creating md5sums..." >> $LOGPATH
    (cd $IMAGEDIR && find . -type f -print0 | xargs -0 md5sum > md5sum.txt)
    echo "debmower: $(date +%H:%M:%S) Creating iso image..." >> $LOGPATH
    cd $IMAGEDIR
    xorriso -as mkisofs -r -V "$IMAGE_NAME" -J -l \
                -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
                -b isolinux/isolinux.bin -input-charset utf8 \
                -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 \
                 -eltorito-boot isolinux/isolinux.bin \
                -boot-info-table -o $ISOPATH/$ISONAME . \
                &> $LOGPATH.xorriso ; abort_on_fail
    SQUASHFS_SIZE=$(du -sh $IMAGEDIR/$LIVEDIR/filesystem.squashfs \
                    | awk '{print $1}')
    if [ -d "$IMAGEDIR/pool" ]; then
        PKG_POOL_SIZE=$(du -sh $IMAGEDIR/pool | awk '{print $1}')
    else
        PKG_POOL_SIZE="0M"
    fi
    ISO_SIZE=$(du -sh $ISOPATH/$ISONAME | awk '{print $1}')

    echo "debmower: $(date +%H:%M:%S) Cleaning up..." >> $LOGPATH
    umount -l $CHROOT
    umount -l /mnt/debmower/squashfs
    umount -l -f /tmp/debmower 
    rm -rf /tmp/debmower
    rm -rf /mnt/debmower
    if [ ! "$KEEP_IMAGEDIR" = "yes" ]; then
        rm -rf $IMAGEDIR
    fi
}


function updatecache {
    mkdir -p $CACHEDIR
    cd $CACHEDIR
    mkdir -p /tmp/debmower
    # You can set TMPFS_SIZE=1000m, to set custom tmpfs size
    if [ -z "$TMPFS_SIZE" ]; then
        SIZEOPT="-o size=$TMPFS_SIZE"
    fi
    mount -t tmpfs tmpfs /tmp/debmower $SIZEOPT
    echo " * $(date +%H:%M:%S) Performing initial debootstrapping for $RELEASE..."
    CHROOT=tmpfs/chroot
    debootstrap $RELEASE $CHROOT $DEBOOTSTRAP_MIRROR &>> $LOGPATH
    echo " * $(date +%H:%M:%S) Installing standard packages..." \
         &>> $LOGFILE.updatecache
    chroot_bind_mounts
    if [ "$CACHEPACKAGES" != "" ]; then
        chroot $CHROOT apt-get --force-yes -qq -y $CACHEPACKAGES \
        &>> $LOGPATH
    fi
    echo "debmower: cleaning up..." &>> $LOGPATH
    echo "debmower: tmpfs size is $(df -h /tmp/debmower | grep debmower | awk '{print $2}')" \
         &>> $LOGPATH
    echo "debmower: tmpfs usage at end was $(df -h /tmp/debmower | grep debmower | awk '{print $4}')" \
         &>> $LOGPATH
    chroot $CHROOT apt-get clean
    chroot_bind_unmounts
    echo "debmower: ... done" &>> $LOGPATH
    # generate squashfs for future ramdisk use
    echo " * $(date +%H:%M:%S) Creating $RELEASE squashfs..."
    mksquashfs $CHROOT $CACHEDIR/$CACHEIMG.squashfs -noappend -no-progress ; abort_on_fail
    rm -rf "$CHROOT"
    umount -l /tmp/debmower
    rmdir /tmp/debmower
    cd ..
    echo "debmower: ... done" &>> $LOGPATH
}


function generate_reports {
    echo "debmower: REPORT: Main meta used is $MAINMETA and live is $LIVECD" >> $LOGPATH
    echo "debmower: REPORT: This $IMAGETYPE uses $COMP for squashfs compression" >> $LOGPATH
    echo "debmower: REPORT: Total packages in manifest: $MANIFEST_PKG packages" \
          >> $LOGPATH
    echo "debmower: REPORT: Live package manifest: $MANIFEST_PKG_RM packages" \
          >> $LOGPATH
    echo "debmower: REPORT: Templates dir: $TEMPLATE" >> $LOGPATH
    echo "debmower: REPORT: Built from cached image: $CACHEIMG" >> $LOGPATH
    echo "debmower: REPORT: Squashfs image size is: $SQUASHFS_SIZE" >> $LOGPATH
    echo "debmower: REPORT: Package pool size is: $PKG_POOL_SIZE" >> $LOGPATH
    echo "debmower: REPORT: ISO size is $ISO_SIZE" >> $LOGPATH
    echo "debmower: $(date +%H:%M:%S) All done." >> $LOGPATH
}


function abort_build {
    echo "debmower: $(date +%H:%M:%S) Aborting..." &>> $LOGPATH
    umount -f -l /mnt/debmower/squashfs
    chroot_bind_unmounts
    umount -f -l $CHROOT
    umount /tmp/debmower 
    rmdir /tmp/debmower/
    exit 299
}


function abort_on_fail {
    if [ "$?" = "0" ]; then
        echo "debmower: $(date +%H:%M:%S) ... completed successfully" \
        >> $LOGPATH
    else
        echo "debmower: ... step has failed," \
        >> $LOGPATH
        echo "          There is no point in going on." >> $LOGPATH
        abort_build
    fi
}


function chroot_bind_mounts {
    mkdir -p $CHROOT/dev/pts $CHROOT/proc/pts \
             $IMAGEDIR/$LIVEDIR $IMAGEDIR/syslinux $CHROOT/etc/apt
    mount --bind /proc $CHROOT/proc
    mount --bind /sys $CHROOT/sys
    mount --bind /dev $CHROOT/dev
    mount --bind /dev/pts $CHROOT/dev/pts
}


function chroot_bind_unmounts {
    umount -f -l $CHROOT/dev/pts
    umount -f -l $CHROOT/dev
    umount -f -l $CHROOT/sys
    umount -f -l $CHROOT/proc
    # This could replace the above, but relies that 'debmower' is in the path,
    # which might not always be the case so we keep the above.
    for mountpoint in $(mount | grep debmower | awk '{print $3}');
        do umount -f -l $mountpoint;
    done
}


if [ "$2" = "updatecache" ]; then
    updatecache
    exit
fi

trap abort_build 2

initenv
system_install
setup_livecd
build_cd_image
generate_reports
